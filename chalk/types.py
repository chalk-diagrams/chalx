"""
Define the core types for chalk.
Designed to be the top of the import
hierarchy.
"""
from __future__ import annotations

from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    Protocol,
    Tuple,
)

import chalk.transform as tx
from chalk.monoid import Monoid
from chalk.style import Stylable, StyleHolder
from chalk.transform import P2_t, V2_t

if TYPE_CHECKING:
    from chalk.arrow import ArrowOpts
    from chalk.backend.patch import Patch
    from chalk.core import Primitive
    from chalk.envelope import Envelope
    from chalk.path import Path
    from chalk.subdiagram import Name, Subdiagram
    from chalk.trace import Trace
    from chalk.trail import Located, Trail
    from chalk.visitor import A, DiagramVisitor


class TrailLike(Protocol):
    def to_trail(self) -> Trail:
        ...

    def to_path(self, location: P2_t = tx.P2(0.0, 0.0)) -> Path:
        return self.at(location).to_path()

    def at(self, location: P2_t) -> Located:
        return self.to_trail().at(location)

    def stroke(self) -> Diagram:
        return self.at(tx.P2(0, 0)).stroke()


class Diagram(Stylable, tx.Transformable, Monoid, tx.Batchable):
    # Standard diagram types
    # Would be nice if these could be autogenerated
    def apply_transform(self: BatchDiagram, t: tx.Affine) -> BroadDiagram:  
        ...

    def __add__(self: BatchDiagram, other: BatchDiagram) -> BroadDiagram:  
        ...

    def __or__(self: BatchDiagram, d: BatchDiagram) -> BroadDiagram:
        ...

    def __truediv__(self: BatchDiagram, other: BatchDiagram) -> BroadDiagram:  
        ...

    def __floordiv__(self: BatchDiagram, other: BatchDiagram) -> BroadDiagram:  
        ...

    def pad(self, extra: tx.Floating) -> Diagram:  
        ...

    def scale_uniform_to_x(self, x: tx.Floating) -> Diagram:  
        ...

    def scale_uniform_to_y(self, y: tx.Floating) -> Diagram:  
        ...

    def align(self: Diagram, v: V2_t) -> Diagram:  
        ...

    def align_t(self: Diagram) -> Diagram:  
        ...

    def align_b(self: Diagram) -> Diagram:  
        ...

    def align_l(self: Diagram) -> Diagram:  
        ...

    def align_r(self: Diagram) -> Diagram:  
        ...

    def align_tl(self: Diagram) -> Diagram:  
        ...

    def align_tr(self: Diagram) -> Diagram:  
        ...

    def align_bl(self: Diagram) -> Diagram:  
        ...

    def align_br(self: Diagram) -> Diagram:  
        ...

    def snug(self: Diagram, v: V2_t) -> Diagram:  
        ...

    def center_xy(self: Diagram) -> Diagram:  
        ...

    def get_subdiagram(self, name: Any) -> Optional[Subdiagram]:
        ...

    def get_sub_map(  
        self, t: tx.Affine
    ) -> Dict[Name, List[Subdiagram]]:
        ...

    def with_names(  
        self,
        names: List[Any],
        f: Callable[[List[Subdiagram], Diagram], Diagram],
    ) -> Diagram:
        ...

    def _style(self, style: StyleHolder) -> Diagram:  
        ...

    def get_envelope(self) -> Envelope:  
        ...

    def _normalize(self) -> Diagram:  
        ...

    def get_trace(self) -> Trace:  
        ...

    def with_envelope(self, other: Diagram) -> Diagram:  
        ...

    def show_origin(self) -> Diagram:  
        ...

    def show_labels(self: Diagram, font_size: tx.Floating = 1) -> Diagram:  
        ...

    def show_envelope(  
        self, phantom: bool = False, angle: int = 45
    ) -> Diagram:
        ...

    def show_beside(  
        self: Diagram, other: Diagram, direction: V2_t
    ) -> Diagram:
        ...

    def compose(  
        self, envelope: Optional[Diagram], other: Optional[Diagram] = None
    ) -> Diagram:
        ...

    def to_list(  
        self, t: tx.Affine
    ) -> List[Diagram]:
        ...

    def accept(  
        self, visitor: DiagramVisitor[A, Any], args: Any
    ) -> A:
        ...

    def get_primitives(  
        self,
    ) -> List[Primitive]:
        ...

    def layout(  
        self,
        height: tx.IntLike,
        width: Optional[tx.IntLike] = None,
        draw_height: Optional[tx.IntLike] = None,
    ) -> Tuple[List[Patch], tx.IntLike, tx.IntLike]:
        ...

    def size(self) -> Tuple[int, ...]:  
        ...

    def compose_axis(self) -> Diagram:  
        ...

    def named(self: Diagram, name: Any) -> Diagram:  
        ...

    def qualify(self: Diagram, name: Any) -> Diagram:  
        ...

    def hcat(  
        self: ExtraDiagram, sep: Optional[tx.Floating] = None
    ) -> BatchDiagram:
        ...

    def vcat(  
        self: ExtraDiagram, sep: Optional[tx.Floating] = None
    ) -> BatchDiagram:
        ...

    def concat(  # type: ignore[empty-body, override]
        self: ExtraDiagram,
    ) -> BatchDiagram:
        ...

    def juxtapose_snug(  
        self: BatchDiagram, other: BatchDiagram, direction: V2_t
    ) -> BroadDiagram:
        ...

    def beside_snug(  
        self: BatchDiagram, other: BatchDiagram, direction: V2_t
    ) -> BroadDiagram:
        ...

    def juxtapose(  
        self: BatchDiagram, other: BatchDiagram, direction: V2_t
    ) -> BroadDiagram:
        ...

    def atop( 
            self: BatchDiagram, other: BatchDiagram) -> BroadDiagram:  
        ...

    def above (
            self: BatchDiagram, other: BatchDiagram) -> BatchDiagram:
        ...

    def beside(  
        self: BatchDiagram, other: BatchDiagram, direction: V2_t
    ) -> BroadDiagram:
        ...

    def connect(  
        self: BatchDiagram,
        name1: Any,
        name2: Any,
        style: Optional[ArrowOpts] = None,
    ) -> BatchDiagram:
        ...

    def connect_outside(  
        self: BatchDiagram,
        name1: Any,
        name2: Any,
        style: Optional[ArrowOpts] = None,
    ) -> BatchDiagram:
        ...

    def connect_perim(
        self: BatchDiagram,
        name1: Any,
        name2: Any,
        v1: V2_t,
        v2: V2_t,
        style: Optional[ArrowOpts] = None,
    ) -> BatchDiagram:
        ...

    def add_axis(self, size: int) -> Diagram:  
        ...

    def repeat_axis( 
            self, size: int, axis: int) -> Diagram:  
        ...

    def broadcast_diagrams(  
        self: BatchDiagram, other: BatchDiagram
    ) -> Tuple[BroadDiagram, BroadDiagram]:
        ...

    def reshape(  
        self, shape: Tuple[int, ...]
    ) -> Diagram:
        ...

    def animate(  
        self: SingleDiagram,
        path: str,
        height: int = 128,
        width: Optional[int] = None,
        draw_height: Optional[int] = None,
    ) -> None:
        ...

    def animate_svg(  
        self: SingleDiagram,
        path: str,
        height: int = 128,
        width: Optional[int] = None,
        draw_height: Optional[int] = None,
    ) -> None:
        ...

    def render(  
        self: SingleDiagram,
        path: str,
        height: int = 128,
        width: Optional[int] = None,
        draw_height: Optional[int] = None,
    ) -> None:
        ...

    def render_svg(  
        self: SingleDiagram,
        path: str,
        height: int = 128,
        width: Optional[int] = None,
        draw_height: Optional[int] = None,
    ) -> None:
        ...

    def render_mpl(  
        self: SingleDiagram,
        path: str,
        height: int = 128,
        width: Optional[int] = None,
        draw_height: Optional[int] = None,
    ) -> None:
        ...


# Diagram with shape
BatchDiagram = tx.Batched[Diagram, "*#B"]

# Broadcasted diagram
BroadDiagram = tx.Batched[Diagram, "*B"]

# Diagram before composition
ExtraDiagram = tx.Batched[Diagram, "*#B A"]
EmptyDiagram = tx.Batched[Diagram, ""]
SingleDiagram = tx.Batched[Diagram, ""]
